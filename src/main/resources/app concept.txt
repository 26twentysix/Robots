observer и observable is deprecated, 
вместо них лучше использовать java.beans.EventHandler и потокобезопасные коллекции из java.util.concurrent


Для первого таска всего 5 частей:

model:
	эта балда это по сути логика, класс "поле", класс "робот" (в нем будет его поведение
	взаимодействует только с презентером, сообщая, что модель обновилась
	для сообщения с презентером генерирует ивенты, в которых говорит, что именно изменилось (чтобы презентер не перерисовывал все окна разом, а только то что нужно)
	мб вспомогательные классы с рассчетами (хотя какие рассчеты, у нас клеточное поле)
	роботы у нас будут воевать, поэтому все что нам надо знать, это где робот стоит и куда смотрит, чтобы нарисовать его правильно
	как работает драка роботов: 
	думаю будет что-то типа тактов, и в каждый так бот будет в соответствии со своим геномом выбирать следующее действие
	считать в одном потоке действия для всех ботов это плохая идея
	поэтому думаю нормальный вариант это создавать небольшие поколения, штук по 20, и запускать каждого отдельным потоком
	как это будет пошагово: //сначала придумать геном, потом уже придумывать как будут крутиться роботы
	1) начало такта, боты прокручивают свой геном пока не упрутся в завершающую команду (шаг, атака), и запоминают её
	2) в основном потоке модели мы ждем всех роботов, пока они не будут готовы (чтобы невелировать эффект вытесняющей многопоточности, когда управление боту переходит после того, как другие сделали свои ходы)
	3) боты совершают запомненные действия, конец такта
	и вот так пошагово боты будут воевать
	что такое геном, как он будет влиять не действия и какие действия будут у роботов придумаем потом
view:
	эта балда умеет рисовать и генерировать ивенты в зависимости от действий пользователя
	тут собраны все кнопки хуёпки текстовые поля рисовалки и прочее, в других компонентах ничего про рисование нет, все здесь
	генерирует ивенты, презентер их слушает и как-то реагирует, изменяя view или вызывая методы у модели
	у нас уже приложение имеет вид нескольких окон, одно окно где боты что-то делают, одно окно с логом, поэтому надо двигаться в эту сторону
	пусть так и будет одно окно с полем боя, другое окно с логом (допустим там будет инфа типа начало драки, такой-то бот сдох, потом сюда же будут выводить сообщения о этапах эволюции)
	и нужно еще окно или текстовое поле с чем-то типа статистики, сколько сейчас ботов на поле, какой режим работы (эволюция или драка)
	в режиме эволюции еще показывать геном последнего победителя, можно с отличиями от прошлого, номер поколения, время боя
	при ускорении показывать за сколько проживается поколение
viewListener:
	интерфейс для презентера, в этом интерфейсе описываются методы реагирования на ивенты от view
	нужен чтобы не привязывать view к конкретной реализации презентера, описывает методы для обработки действий
	по сути, у него будет только одна реализация, как раз презентер, но умные дяди в книжках обычно херню не говорят
presenter:
	является связующим звеном, слушает ивенты от модели и view, взаимодействует соответственно с обоими
	от модели получает ивенты вида "я обновилась, вот здесь", после чего вызывает методы view для отрисовки обновленных данных
	от view получает ивенты вида "пользователь тыкнул вот это", после чего обрабатывает это двумя путями:
	1) это был ресайз окна, закрытие, и прочее косметическое взаимодействие - презентер сразу меняет view в соответствии с этим
	2) какое-то воздействие на модель, тогда вызываются соответствующие методы модели, модель обновляется
application:
	это наш Main, в нем создаются презентер, модель, view, связываются друг с другом и запускаются работать
	отсюда же потом будем запускать эволюцию, это будет отдельный модуль
	
Как будем делать эволюцию:
	я думаю будет правильно создать две версии модели - просто дерущиеся роботы, пусть они там как-нибудь воюют, и эволюционирующую модель
	в простой модели боты будут просто драться, как получиться, это чисто база
	а эволюционирующая модель будет работать так:
	0) запускаем на поле Н роботов с рандомным геномом, они сражаются, пока не останется один бот
	1) создаем Н копий генома победившего робота, в каждой копии меняем один ген поведения, рандомно
	2) очищаем боевое поле
	3) по каждой новой копии генома создаем нового робота и запускаем на поле сражаться
	и вот так оно будет крутиться, надо еще подумать над тем как это дело ускорять или замедлять
